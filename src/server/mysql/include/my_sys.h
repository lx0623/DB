//
// Created by tengjp on 19-7-16.
//

#ifndef AIRES_MY_SYS_H
#define AIRES_MY_SYS_H

#include <string>
#include <time.h>
#include <sys/types.h>
#include <unistd.h>
#include "./my_global.h"
#include "mysql_thread.h"

#define my_b_EOF INT_MIN

/* Flags for my_error() */
#define ME_BELL		4	/* DEPRECATED: Ring bell then printing message */
#define ME_ERRORLOG	64	/* Write the error message to error log */
#define ME_FATALERROR   1024    /* Fatal statement error */

/**
  Max length of an error message generated by mysys utilities.
  Some mysys functions produce error messages. These mostly go
  to stderr.
  This constant defines the size of the buffer used to format
  the message. It should be kept in sync with MYSQL_ERRMSG_SIZE,
  since sometimes mysys errors are stored in the server diagnostics
  area, and we would like to avoid unexpected truncation.
*/
#define MYSYS_ERRMSG_SIZE   (1024)
#define MYSYS_STRERROR_SIZE (1024)
#define MY_FILE_ERROR	((size_t) -1)

/* General bitmaps for my_func's */
#define MY_FFNF		1	/* Fatal if file not found */
#define MY_FNABP	2	/* Fatal if not all bytes read/writen */
#define MY_NABP		4	/* Error if not all bytes read/writen */
#define MY_FAE		8	/* Fatal if any error */
#define MY_WME		16	/* Write message on error */
#define MY_WAIT_IF_FULL 32	/* Wait and try again if disk full error */
#define MY_IGNORE_BADFD 32      /* my_sync: ignore 'bad descriptor' errors */
#define MY_SYNC_DIR     8192    /* my_create/delete/rename: sync directory */
#define MY_UNUSED       64      /* Unused (was support for RAID) */
#define MY_FULL_IO     512      /* For my_read - loop intil I/O is complete */
#define MY_DONT_CHECK_FILESIZE 128 /* Option to init_io_cache() */
#define MY_LINK_WARNING 32	/* my_redel() gives warning if links */
#define MY_COPYTIME	64	/* my_redel() copys time */
#define MY_DELETE_OLD	256	/* my_create_with_symlink() */
#define MY_RESOLVE_LINK 128	/* my_realpath(); Only resolve links */
#define MY_HOLD_ORIGINAL_MODES 128  /* my_copy() holds to file modes */
#define MY_REDEL_MAKE_BACKUP 256
#define MY_REDEL_NO_COPY_STAT 512 /* my_redel() doesn't call my_copystat() */
#define MY_SEEK_NOT_DONE 32	/* my_lock may have to do a seek */
#define MY_DONT_WAIT	64	/* my_lock() don't wait if can't lock */
#define MY_ZEROFILL	32	/* my_malloc(), fill array with zero */
#define MY_ALLOW_ZERO_PTR 64	/* my_realloc() ; zero ptr -> malloc */
#define MY_FREE_ON_ERROR 128	/* my_realloc() ; Free old ptr on error */
#define MY_HOLD_ON_ERROR 256	/* my_realloc() ; Return old ptr on error */
#define MY_DONT_OVERWRITE_FILE 1024	/* my_copy: Don't overwrite file */
#define MY_THREADSAFE 2048      /* my_seek(): lock fd mutex */
#define MY_SYNC       4096      /* my_copy(): sync dst file */
#define MY_DIRECT    16384      /* my_read(): align since O_DIRECT used */

#define MY_CHECK_ERROR	1	/* Params to my_end; Check open-close */
#define MY_GIVE_INFO	2	/* Give time info about process*/
#define MY_DONT_FREE_DBUG 4     /* Do not call DBUG_END() in my_end() */

#define ME_HIGHBYTE	8	/* Shift for colours */
#define ME_NOCUR	1	/* Don't use curses message */
#define ME_OLDWIN	2	/* Use old window */
#define ME_BELL		4	/* Ring bell then printing message */
#define ME_HOLDTANG	8	/* Don't delete last keys */
#define ME_WAITTOT	16	/* Wait for errtime secs of for a action */
#define ME_WAITTANG	32	/* Wait for a user action  */
#define ME_NOREFRESH	64	/* Write the error message to error log */
#define ME_NOINPUT	128	/* Dont use the input libary */
#define ME_COLOUR1	((1 << ME_HIGHBYTE))	/* Possibly error-colours */
#define ME_COLOUR2	((2 << ME_HIGHBYTE))
#define ME_COLOUR3	((3 << ME_HIGHBYTE))
#define ME_FATALERROR   1024    /* Fatal statement error */

/* Bits in last argument to fn_format */
#define MY_REPLACE_DIR		1	/* replace dir in name with 'dir' */
#define MY_REPLACE_EXT		2	/* replace extension with 'ext' */
#define MY_UNPACK_FILENAME	4	/* Unpack name (~ -> home) */
#define MY_PACK_FILENAME	8	/* Pack name (home -> ~) */
#define MY_RESOLVE_SYMLINKS	16	/* Resolve all symbolic links */
#define MY_RETURN_REAL_PATH	32	/* return full path for file */
#define MY_SAFE_PATH		64	/* Return NULL if too long path */
#define MY_RELATIVE_PATH	128	/* name is relative to 'dir' */
#define MY_APPEND_EXT           256     /* add 'ext' as additional extension*/


/* My seek flags */
#define MY_SEEK_SET	0
#define MY_SEEK_CUR	1
#define MY_SEEK_END	2

/* Some constants */
#define MY_WAIT_FOR_USER_TO_FIX_PANIC	60	/* in seconds */
#define MY_WAIT_GIVE_USER_A_MESSAGE	10	/* Every 10 times of prev */
#define MIN_COMPRESS_LENGTH		50	/* Don't compress small bl. */
#define DFLT_INIT_HITS  3

/* root_alloc flags */
#define MY_KEEP_PREALLOC	1
#define MY_MARK_BLOCKS_FREE     2  /* move used to free list and reuse them */

/* Internal error numbers (for assembler functions) */
#define MY_ERRNO_EDOM		33
#define MY_ERRNO_ERANGE		34

/* Bits for get_date timeflag */
#define GETDATE_DATE_TIME	1
#define GETDATE_SHORT_DATE	2
#define GETDATE_HHMMSSTIME	4
#define GETDATE_GMT		8
#define GETDATE_FIXEDLENGTH	16
extern void *my_multi_malloc(myf MyFlags, ...);

extern int create_temp_file(char *to, const char *dir, const char *prefix);
extern size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags);
extern my_off_t my_tell(File fd,myf MyFlags);
extern my_off_t my_seek(File fd, my_off_t pos, int whence, myf MyFlags);
size_t my_read(File Filedes, uchar *Buffer, size_t Count, myf MyFlags);
std::string filename( int fd );
extern size_t dirname_part(char * to,const char *name, size_t *to_res_length);
extern size_t dirname_length(const char *name);
#define base_name(A) (A+dirname_length(A))
extern int test_if_hard_path(const char *dir_name);
extern my_bool has_path(const char *name);
extern char *convert_dirname(char *to, const char *from, const char *from_end);
extern void to_unix_path(char * name);
extern char * fn_ext(const char *name);
extern char * fn_same(char * toname,const char *name,int flag);
extern char * fn_format(char * to,const char *name,const char *dir,
                        const char *form, uint flag);
extern size_t strlength(const char *str);
extern void pack_dirname(char * to,const char *from);
extern size_t normalize_dirname(char * to, const char *from);
extern size_t unpack_dirname(char * to,const char *from);
extern size_t cleanup_dirname(char * to,const char *from);
extern size_t system_filename(char * to,const char *from);
extern size_t unpack_filename(char * to,const char *from);
extern char * intern_filename(char * to,const char *from);
extern int pack_filename(char * to, const char *name, size_t max_length);
extern int my_readlink(char *to, const char *filename, myf MyFlags);
// extern int my_is_symlink(const char *filename, ST_FILE_ID *file_id);
extern int my_realpath(char *to, const char *filename, myf MyFlags);
// extern int my_is_same_file(File file, const ST_FILE_ID *file_id);
extern int my_getwd(char * buf, size_t size, myf MyFlags);
extern int my_setwd(const char *dir, myf MyFlags);
extern char * my_load_path(char * to, const char *path,
                           const char *own_path_prefix);

static inline my_off_t
inline_mysql_file_tell(
        File file, myf flags)
{
    my_off_t result;
    result= my_tell(file, flags);
    return result;
}

static inline my_off_t
inline_mysql_file_seek(
        File file, my_off_t pos, int whence, myf flags)
{
    my_off_t result;

    result= my_seek(file, pos, whence, flags);
    return result;
}
static inline size_t
inline_mysql_file_read(
        File file, uchar *buffer, size_t count, myf flags)
{
    size_t result;

    result= my_read(file, buffer, count, flags);
    return result;
}

enum cache_type
{
    TYPE_NOT_SET= 0, READ_CACHE, WRITE_CACHE,
    SEQ_READ_APPEND		/* sequential read or append */,
    READ_FIFO, READ_NET,WRITE_NET};
struct st_io_cache;
typedef int (*IO_CACHE_CALLBACK)(struct st_io_cache*);

typedef struct st_io_cache_share
{
    mysql_mutex_t       mutex;           /* To sync on reads into buffer. */
    mysql_cond_t        cond;            /* To wait for signals. */
    mysql_cond_t        cond_writer;     /* For a synchronized writer. */
    /* Offset in file corresponding to the first byte of buffer. */
    my_off_t              pos_in_file;
    /* If a synchronized write cache is the source of the data. */
    struct st_io_cache    *source_cache;
    uchar                 *buffer;         /* The read buffer. */
    uchar                 *read_end;       /* Behind last valid byte of buffer. */
    int                   running_threads; /* threads not in lock. */
    int                   total_threads;   /* threads sharing the cache. */
    int                   error;           /* Last error. */
} IO_CACHE_SHARE;

typedef struct st_io_cache		/* Used when cacheing files */
{
    /* Offset in file corresponding to the first byte of uchar* buffer. */
    my_off_t pos_in_file;
    /*
      The offset of end of file for READ_CACHE and WRITE_CACHE.
      For SEQ_READ_APPEND it the maximum of the actual end of file and
      the position represented by read_end.
    */
    my_off_t end_of_file;
    /* Points to current read position in the buffer */
    uchar	*read_pos;
    /* the non-inclusive boundary in the buffer for the currently valid read */
    uchar  *read_end;
    uchar  *buffer;				/* The read buffer */
    /* Used in ASYNC_IO */
    uchar  *request_pos;

    /* Only used in WRITE caches and in SEQ_READ_APPEND to buffer writes */
    uchar  *write_buffer;
    /*
      Only used in SEQ_READ_APPEND, and points to the current read position
      in the write buffer. Note that reads in SEQ_READ_APPEND caches can
      happen from both read buffer (uchar* buffer) and write buffer
      (uchar* write_buffer).
    */
    uchar *append_read_pos;
    /* Points to current write position in the write buffer */
    uchar *write_pos;
    /* The non-inclusive boundary of the valid write area */
    uchar *write_end;

    /*
      Current_pos and current_end are convenience variables used by
      my_b_tell() and other routines that need to know the current offset
      current_pos points to &write_pos, and current_end to &write_end in a
      WRITE_CACHE, and &read_pos and &read_end respectively otherwise
    */
    uchar  **current_pos, **current_end;

    /*
      The lock is for append buffer used in SEQ_READ_APPEND cache
      need mutex copying from append buffer to read buffer.
    */
    mysql_mutex_t append_buffer_lock;
    /*
      The following is used when several threads are reading the
      same file in parallel. They are synchronized on disk
      accesses reading the cached part of the file asynchronously.
      It should be set to NULL to disable the feature.  Only
      READ_CACHE mode is supported.
    */
    IO_CACHE_SHARE *share;

    /*
      A caller will use my_b_read() macro to read from the cache
      if the data is already in cache, it will be simply copied with
      memcpy() and internal variables will be accordinging updated with
      no functions invoked. However, if the data is not fully in the cache,
      my_b_read() will call read_function to fetch the data. read_function
      must never be invoked directly.
    */
    int (*read_function)(struct st_io_cache *,uchar *,size_t);
    /*
      Same idea as in the case of read_function, except my_b_write() needs to
      be replaced with my_b_append() for a SEQ_READ_APPEND cache
    */
    int (*write_function)(struct st_io_cache *,const uchar *,size_t);
    /*
      Specifies the type of the cache. Depending on the type of the cache
      certain operations might not be available and yield unpredicatable
      results. Details to be documented later
    */
    enum cache_type type;
    /*
      Callbacks when the actual read I/O happens. These were added and
      are currently used for binary logging of LOAD DATA INFILE - when a
      block is read from the file, we create a block create/append event, and
      when IO_CACHE is closed, we create an end event. These functions could,
      of course be used for other things
    */
    IO_CACHE_CALLBACK pre_read;
    IO_CACHE_CALLBACK post_read;
    IO_CACHE_CALLBACK pre_close;
    /*
      Counts the number of times, when we were forced to use disk. We use it to
      increase the binlog_cache_disk_use and binlog_stmt_cache_disk_use status
      variables.
    */
    ulong disk_writes;
    void* arg;				/* for use by pre/post_read */
    char *file_name;			/* if used with 'open_cached_file' */
    char *dir,*prefix;
    File file; /* file descriptor */
    // PSI_file_key file_key; /* instrumented file key */

    /*
      seek_not_done is set by my_b_seek() to inform the upcoming read/write
      operation that a seek needs to be preformed prior to the actual I/O
      error is 0 if the cache operation was successful, -1 if there was a
      "hard" error, and the actual number of I/O-ed bytes if the read/write was
      partial.
    */
    int	seek_not_done,error;
    /* buffer_length is memory size allocated for buffer or write_buffer */
    size_t	buffer_length;
    /* read_length is the same as buffer_length except when we use async io */
    size_t  read_length;
    myf	myflags;			/* Flags used to my_read/my_write */
    /*
      alloced_buffer is 1 if the buffer was allocated by init_io_cache() and
      0 if it was supplied by the user.
      Currently READ_NET is the only one that will use a buffer allocated
      somewhere else
    */
    my_bool alloced_buffer;

    long read_time; // total read time
} IO_CACHE;

extern int init_io_cache_ext(IO_CACHE *info,File file,size_t cachesize,
                             enum cache_type type,my_off_t seek_offset,
                             pbool use_async_io, myf cache_myflags/*,
                             PSI_file_key file_key*/);
extern int init_io_cache(IO_CACHE *info,File file,size_t cachesize,
                         enum cache_type type,my_off_t seek_offset,
                         pbool use_async_io, myf cache_myflags);
extern my_bool reinit_io_cache(IO_CACHE *info,enum cache_type type,
                               my_off_t seek_offset,pbool use_async_io,
                               pbool clear_cache);
extern void setup_io_cache(IO_CACHE* info);
extern int end_io_cache(IO_CACHE *info);
extern int _my_b_read(IO_CACHE *info,uchar *Buffer,size_t Count);
extern int _my_b_read_r(IO_CACHE *info,uchar *Buffer,size_t Count);
extern void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,
                                IO_CACHE *write_cache, uint num_threads);
extern void remove_io_thread(IO_CACHE *info);
extern int _my_b_seq_read(IO_CACHE *info,uchar *Buffer,size_t Count);
extern int _my_b_net_read(IO_CACHE *info,uchar *Buffer,size_t Count);
extern int _my_b_get(IO_CACHE *info);
extern int _my_b_write(IO_CACHE *info,const uchar *Buffer,size_t Count);
extern int my_b_append(IO_CACHE *info,const uchar *Buffer,size_t Count);
extern int my_b_safe_write(IO_CACHE *info,const uchar *Buffer,size_t Count);
extern int my_b_flush_io_cache(IO_CACHE *info, int need_append_buffer_lock);

#define my_b_tell(info) ((info)->pos_in_file + \
			 (size_t) (*(info)->current_pos - (info)->request_pos) )
#define my_b_get(info) \
  ((info)->read_pos != (info)->read_end ?\
   ((info)->read_pos++, (int) (uchar) (info)->read_pos[-1]) :\
   _my_b_get(info))
#endif //AIRES_MY_SYS_H
